Express-додаток для роботи з колекцією нотаток

## Загальна мета

У цьому завданні ви продовжите розробку свого Express-додатку (у тому ж репозиторії nodejs-hw).
Цього разу ви реалізуєте:
- реєстрацію,
- логін,
- логаут користувачів,
- сесії,
- кукі,
- приватні колекції нотаток.

## + Критерії прийому

+ Завдання виконано у гілці 04-auth
+ Надано посилання на репозиторій із вихідним кодом на GitHub
+ Надано посилання на задеплоєний проєкт на render.com
+ Код працює без помилок
+ Сервер успішно підключається до MongoDB
+ Порт і адреса бази зберігаються у .env через змінні PORT і MONGO_URL
+ Реалізована обробка неіснуючих маршрутів (404)
+ Реалізована обробка помилок сервера (500 або специфічні помилки через http-errors)
+ Файлова структура відповідає вимогам (див. нижче)
+ Після змін, які вносите у своєму репозиторії, почекайте, будь ласка, 5 хвилин перед відправкою роботи на перевірку. Адже гітхабу необхідний час, щоб оновити версію

## + Модель користувача

+ У файлі src/models/user.js створіть модель User із такими властивостями:

+ username — рядок, не обов’язкове поле, з параметром trim: true;
+ email — рядок, унікальне, обов’язкове, з параметром trim: true;
+ password — рядок, обов’язкове, мінімальна довжина — 8 символів.

+ Для автоматичного створення полів createdAt та updatedAt, використовуйте параметр timestamps: true при створенні моделі.

+ Додайте до схеми userSchema метод toJSON, щоб видаляти пароль із об'єкта користувача перед відправкою у відповідь.

+ Створіть хук pre('save'), щоб за замовчуванням встановлювати username таким самим, як email, при створенні користувача.

## Модель сесії

У файлі src/models/session.js створіть модель Session із такими властивостями:

userId — тип Schema.Types.ObjectId, обов’язкове, посилання на модель User;
accessToken — рядок, обов’язкове;
refreshToken — рядок, обов’язкове;
accessTokenValidUntil — тип Date, обов’язкове;
refreshTokenValidUntil — тип Date, обов’язкове.
Для автоматичного створення полів createdAt та updatedAt, використовуйте параметр timestamps: true при створенні моделі.

## Константи часу

Для роботи з кукі сесії створіть файл src/constants/time.js і збережіть у ньому значення тривалості в мілісекундах:

export const FIFTEEN_MINUTES = 15 * 60 * 1000;
export const ONE_DAY = 24 * 60 * 60 * 1000;

## Допоміжні функції

У src/services/auth.js реалізуйте дві функції:

createSession(userId) — створює access та refresh токени, створює сесію в базі даних і повертає її;
setSessionCookies(res, session) — додає до відповіді три кукі:
accessToken
refreshToken
sessionId

При встановленні кожної кукі обов’язково використовуйте однакові параметри:

httpOnly: true
secure: true
sameSite: 'none'
maxAge: для accessToken — 15 хв, для refreshToken і sessionId — 1 день.

## - Реєстрація користувача

+ У файлі у src/routes/authRoutes.js реалізуйте маршрут POST /auth/register для реєстрації нового користувача.

+ Тіло запиту має містити:

+ email — рядок, email, обов’язкове;
+ password — рядок, мінімум 8 символів, обов’язкове (на сервері хешується через bcrypt).

+ Додайте валідацію вхідних даних за допомогою бібліотеки celebrate.

+ у файлі src/validations/authValidation.js створіть схему валідації registerUserSchema для тіла запиту, використовуючи Joi.object({...});
додайте цю схему до маршруту як middleware у src/routes/authRoutes.js.

+ У файлі src/controllers/authController.js створіть контролер + registerUser, який:

+ Перевіряє, чи користувач із таким email вже існує. Якщо так — повертає через createHttpError помилку зі статусом 400 і повідомленням 'Email in use';
+ Хешує пароль за допомогою bcrypt;
+ Створює нового користувача в базі;
- Створює нову сесію (createSession) і додає кукі (setSessionCookies) до відповіді;
+ У разі вдалої обробки запиту повертає відповідь зі статусом 201 і об’єктом створеного користувача (без пароля завдяки методу схеми toJSON) — res.status(201).json(user).

## Логін користувача

У файлі у src/routes/authRoutes.js реалізуйте маршрут POST /auth/login для логіну зареєстрованого користувача.

Тіло запиту має містити:

email — рядок, email, обов’язкове
password — рядок, обов’язкове

Додайте валідацію вхідних даних за допомогою бібліотеки celebrate.

у файлі src/validations/authValidation.js створіть схему валідації loginUserSchema для тіла запиту, використовуючи Joi.object({...}).
додайте цю схему до маршруту як middleware у src/routes/authRoutes.js.

У файлі src/controllers/authController.js створіть контролер loginUser, який:

перевіряє, чи користувач із таким email існує в базі даних. Якщо ні — повертає через createHttpError помилку зі статусом 401 і повідомленням 'Invalid credentials';
перевіряє чи вірний пароль. Якщо ні — повертає через createHttpError помилку зі статусом 401 і повідомленням 'Invalid credentials';
видаляє стару сесію цього користувача та створює нову (createSession) і додає кукі (setSessionCookies) до відповіді;
У разі вдалої обробки запиту повертає відповідь зі статусом 200 і об’єктом залогіненого користувача (без пароля завдяки методу схеми toJSON) — res.status(200).json(user).

## Оновлення сесії

У файлі у src/routes/authRoutes.js реалізуйте маршрут POST /auth/refreshдля для оновлення сесії користувача.

Маршрут не приймає тіло запиту, всі необхідні дані (sessionId, refreshToken) беруться з cookies.

У файлі src/controllers/authController.js створіть контролер refreshUserSession, який:

шукає у базі даних сесію за sessionId та refreshToken з cookies;
якщо сесія не знайдена — повертає через createHttpError помилку зі статусом 401 і повідомленням 'Session not found';
перевіряє, чи не прострочений refresh-токен; якщо так — повертає через createHttpError помилку зі статусом 401 і повідомленням 'Session token expired';
видаляє стару сесію з бази;
створює нову сесію (createSession) і додає нові кукі (setSessionCookies) до відповіді;
у разі вдалої обробки запиту повертає відповідь зі статусом 200 і об’єктом:

{
  "message": "Session refreshed"
}

## Логаут користувача

У файлі src/routes/authRoutes.js реалізуйте маршрут POST /auth/logout для виходу користувача із системи.

Маршрут не приймає тіло запиту, усі необхідні дані (sessionId) беруться з cookies.

У файлі src/controllers/authController.js створіть контролер logoutUser, який:

перевіряє, чи є у cookies sessionId. Якщо є — видаляє відповідну сесію з бази даних;
очищає cookies sessionId, accessToken та refreshToken за допомогою res.clearCookie;
повертає відповідь зі статусом 204 (без тіла).

## Middleware аутентифікації

У файлі src/middlewares/authenticate.js створіть middleware authenticate, який:

перевіряє наявність кукі accessToken. Якщо accessToken відсутній — повертає через createHttpError помилку зі статусом 401 і повідомленням 'Missing access token'. Якщо присутній — шукає у базі даних сесію за цим токеном. Якщо така сесія відсутня — повертає через createHttpError помилку зі статусом 401 і повідомленням 'Session not found';
перевіряє, чи не прострочений access-токен. Якщо прострочений — повертає через createHttpError помилку зі статусом 401 і повідомленням 'Access token expired';
шукає користувача, пов’язаного з цією сесією. Якщо такий користувач не знайдено — повертає через createHttpError помилку зі статусом 401 без повідомлення;
у разі успіху додає об’єкт знайденого користувача в req.user і викликає next().

Цей middleware має бути застосований до всіх роутів нотаток, щоб забезпечити доступ лише для авторизованих користувачів.

## Колекція нотаток

Розширте модель Note обов’язковим полем userId (тип ObjectId, посилання на модель User).

Оновіть усі контролери колекції нотаток:

createNote — при створенні додавайте userId з req.user._id;
getAllNotes — повертайте лише нотатки, що належать поточному користувачу. Зверніть увагу, що метод findById тепер не підійде;
getNoteById — шукайте нотатку за _id, яка належить поточному користувачу;
updateNote — оновлювати можна лише нотатку, яка належить поточному користувачу;
deleteNote — видаляти можна лише нотатку, яка належить поточному користувачу.

Якщо нотатку не знайдено (бо вона не існує або належить іншому користувачу) — повертати через createHttpError помилку зі статусом 404 і повідомлення 'Note not found'.

## Деплой

Задеплойте ваш додаток з гілки 04-auth на render.com.

Дуже важливо перед здачею дз на перевірку ментору перевіряти роботу вашого задеплоєного додатка на render.com. Якщо, наприклад, при деплої ви забули додати змінні оточення (env), то задеплоєний бекенд не буде працювати. Також перевірте, що всі створені вами маршрути бекенду працюють як очікується згідно з завданням.
